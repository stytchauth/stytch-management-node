// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import { ClientError } from "./shared/errors";
import { fetchConfig } from "./shared";
import { request } from "./shared";

export interface PEMFile {
  // PEMFileID is the unique identifier for the PEM file.
  pem_file_id: string;
  // PublicKey is the public key content.
  public_key: string;
}

export interface TrustedTokenProfile {
  // ProfileID is the unique identifier for the trusted token profile.
  profile_id: string;
  // Name is a human-readable name. This does not have to be unique.
  name: string;
  // Audience is the audience for the trusted token profile.
  audience: string;
  // Issuer is the issuer for the trusted token profile.
  issuer: string;
  // PEMFiles is a list of PEM files.
  pem_files: PEMFile[];
  // CanJITProvision indicates whether the trusted token profile can be provisioned JIT.
  can_jit_provision: boolean;
  // JwksURL is the JWKS URL for the trusted token profile.
  jwks_url?: string;
  // AttributeMapping is the attribute mapping for the trusted token profile.
  attribute_mapping?: Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
  // PublicKeyType is the type of public key.
  public_key_type?: "JWK" | "PEM" | string;
}

// Request type for `trustedTokenProfiles.createPEMFile`.
export interface CreatePEMFileRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
  // ProfileID is the unique identifier for the trusted token profile.
  profile_id: string;
  // PublicKey is the public key content.
  public_key: string;
}

// Response type for `trustedTokenProfiles.createPEMFile`.
export interface CreatePEMFileResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // PEMFile is the PEM file that was created.
  pem_file: PEMFile;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `trustedTokenProfiles.create`.
export interface CreateRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
  // Name is a human-readable name. This does not have to be unique.
  name: string;
  // Audience is the audience for the trusted token profile.
  audience: string;
  // Issuer is the issuer for the trusted token profile.
  issuer: string;
  // PEMFiles is a list of PEM files.
  pem_files: string[];
  // CanJITProvision indicates whether the trusted token profile can be provisioned JIT.
  can_jit_provision: boolean;
  // JwksURL is the JWKS URL for the trusted token profile.
  jwks_url?: string;
  // AttributeMapping is the attribute mapping for the trusted token profile.
  attribute_mapping?: Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
  // PublicKeyType is the type of public key.
  public_key_type?: "JWK" | "PEM" | string;
}

// Response type for `trustedTokenProfiles.create`.
export interface CreateResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // TrustedTokenProfile is the trusted token profile that was created.
  profile: TrustedTokenProfile;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `trustedTokenProfiles.deletePEMFile`.
export interface DeletePEMFileRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
  // ProfileID is the unique identifier for the trusted token profile.
  profile_id: string;
  // PEMFileID is the unique identifier for the PEM file.
  pem_file_id: string;
}

// Response type for `trustedTokenProfiles.deletePEMFile`.
export interface DeletePEMFileResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `trustedTokenProfiles.delete`.
export interface DeleteRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
  // ProfileID is the unique identifier for the trusted token profile.
  profile_id: string;
}

// Response type for `trustedTokenProfiles.delete`.
export interface DeleteResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `trustedTokenProfiles.getAll`.
export interface GetAllRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
}

// Response type for `trustedTokenProfiles.getAll`.
export interface GetAllResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // A list of all trusted token profiles for the project.
  profiles: TrustedTokenProfile[];
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `trustedTokenProfiles.getPEMFile`.
export interface GetPEMFileRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
  // ProfileID is the unique identifier for the trusted token profile.
  profile_id: string;
  // PEMFileID is the unique identifier for the PEM file.
  pem_file_id: string;
}

// Response type for `trustedTokenProfiles.getPEMFile`.
export interface GetPEMFileResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // PEMFile is the PEM file that was retrieved.
  pem_file: PEMFile;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `trustedTokenProfiles.get`.
export interface GetRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
  // ProfileID is the unique identifier for the trusted token profile.
  profile_id: string;
}

// Response type for `trustedTokenProfiles.get`.
export interface GetResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // TrustedTokenProfile is the trusted token profile.
  profile: TrustedTokenProfile;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `trustedTokenProfiles.update`.
export interface UpdateRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  // EnvironmentSlug is the slug of the environment.
  environment_slug: string;
  // ProfileID is the unique identifier for the trusted token profile.
  profile_id: string;
  // Name is a human-readable name. This does not have to be unique.
  name?: string;
  // Audience is the audience for the trusted token profile.
  audience?: string;
  // Issuer is the issuer for the trusted token profile.
  issuer?: string;
  // JwksURL is the JWKS URL for the trusted token profile.
  jwks_url?: string;
  // AttributeMapping is the attribute mapping for the trusted token profile.
  attribute_mapping?: Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
  // CanJITProvision indicates whether the trusted token profile can be provisioned JIT.
  can_jit_provision?: boolean;
}

// Response type for `trustedTokenProfiles.update`.
export interface UpdateResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // TrustedTokenProfile is the trusted token profile that was updated.
  profile: TrustedTokenProfile;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

export class TrustedTokenProfiles {
  private fetchConfig: fetchConfig;

  constructor(fetchConfig: fetchConfig) {
    this.fetchConfig = fetchConfig;
  }

  /**
   * Create creates a trusted token profile for an environment.
   * @param data {@link CreateRequest}
   * @returns {@link CreateResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async create(data: CreateRequest): Promise<CreateResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    return request<CreateResponse>(this.fetchConfig, {
      method: "POST",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/environments/${encodeURIComponent(
        data.environment_slug
      )}/trusted_token_profiles`,
      data: {
        name: data.name,
        audience: data.audience,
        issuer: data.issuer,
        pem_files: data.pem_files,
        can_jit_provision: data.can_jit_provision,
        jwks_url: data.jwks_url,
        attribute_mapping: data.attribute_mapping,
        public_key_type: data.public_key_type,
      },
    });
  }

  /**
   * Get retrieves the trusted token profile for an environment.
   * @param params {@link GetRequest}
   * @returns {@link GetResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async get(params: GetRequest): Promise<GetResponse> {
    if (!params.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!params.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    if (!params.profile_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "profile_id cannot be empty"
      );
    }
    return request<GetResponse>(this.fetchConfig, {
      method: "GET",
      url: `/pwa/v3/projects/${encodeURIComponent(
        params.project_slug
      )}/environments/${encodeURIComponent(
        params.environment_slug
      )}/trusted_token_profiles/${encodeURIComponent(params.profile_id)}`,
      params: {},
    });
  }

  /**
   * GetAll retrieves all the trusted token profiles for an environment.
   * @param params {@link GetAllRequest}
   * @returns {@link GetAllResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async getAll(params: GetAllRequest): Promise<GetAllResponse> {
    if (!params.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!params.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    return request<GetAllResponse>(this.fetchConfig, {
      method: "GET",
      url: `/pwa/v3/projects/${encodeURIComponent(
        params.project_slug
      )}/environments/${encodeURIComponent(
        params.environment_slug
      )}/trusted_token_profiles`,
      params: {},
    });
  }

  /**
   * Update updates a trusted token profile for an environment.
   * @param data {@link UpdateRequest}
   * @returns {@link UpdateResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async update(data: UpdateRequest): Promise<UpdateResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    if (!data.profile_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "profile_id cannot be empty"
      );
    }
    return request<UpdateResponse>(this.fetchConfig, {
      method: "PATCH",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/environments/${encodeURIComponent(
        data.environment_slug
      )}/trusted_token_profiles/${encodeURIComponent(data.profile_id)}`,
      data: {
        name: data.name,
        audience: data.audience,
        issuer: data.issuer,
        jwks_url: data.jwks_url,
        attribute_mapping: data.attribute_mapping,
        can_jit_provision: data.can_jit_provision,
      },
    });
  }

  /**
   * Delete deletes a trusted token profile for an environment.
   * @param data {@link DeleteRequest}
   * @returns {@link DeleteResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async delete(data: DeleteRequest): Promise<DeleteResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    if (!data.profile_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "profile_id cannot be empty"
      );
    }
    return request<DeleteResponse>(this.fetchConfig, {
      method: "DELETE",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/environments/${encodeURIComponent(
        data.environment_slug
      )}/trusted_token_profiles/${encodeURIComponent(data.profile_id)}`,
      data: {},
    });
  }

  /**
   * CreatePEM creates a PEM file for a trusted token profile for an environment.
   * @param data {@link CreatePEMFileRequest}
   * @returns {@link CreatePEMFileResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async createPEMFile(
    data: CreatePEMFileRequest
  ): Promise<CreatePEMFileResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    if (!data.profile_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "profile_id cannot be empty"
      );
    }
    return request<CreatePEMFileResponse>(this.fetchConfig, {
      method: "POST",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/environments/${encodeURIComponent(
        data.environment_slug
      )}/trusted_token_profiles/${encodeURIComponent(data.profile_id)}/keys`,
      data: {
        public_key: data.public_key,
      },
    });
  }

  /**
   * DeletePEM deletes a PEM file for a trusted token profile for an environment.
   * @param data {@link DeletePEMFileRequest}
   * @returns {@link DeletePEMFileResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async deletePEMFile(
    data: DeletePEMFileRequest
  ): Promise<DeletePEMFileResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    if (!data.profile_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "profile_id cannot be empty"
      );
    }
    if (!data.pem_file_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "pem_file_id cannot be empty"
      );
    }
    return request<DeletePEMFileResponse>(this.fetchConfig, {
      method: "DELETE",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/environments/${encodeURIComponent(
        data.environment_slug
      )}/trusted_token_profiles/${encodeURIComponent(
        data.profile_id
      )}/keys/${encodeURIComponent(data.pem_file_id)}`,
      data: {},
    });
  }

  /**
   * GetPEM retrieves a PEM file for a trusted token profile for an environment.
   * @param params {@link GetPEMFileRequest}
   * @returns {@link GetPEMFileResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async getPEMFile(params: GetPEMFileRequest): Promise<GetPEMFileResponse> {
    if (!params.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!params.environment_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "environment_slug cannot be empty"
      );
    }
    if (!params.profile_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "profile_id cannot be empty"
      );
    }
    if (!params.pem_file_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "pem_file_id cannot be empty"
      );
    }
    return request<GetPEMFileResponse>(this.fetchConfig, {
      method: "GET",
      url: `/pwa/v3/projects/${encodeURIComponent(
        params.project_slug
      )}/environments/${encodeURIComponent(
        params.environment_slug
      )}/trusted_token_profiles/${encodeURIComponent(
        params.profile_id
      )}/keys/${encodeURIComponent(params.pem_file_id)}`,
      params: {},
    });
  }
}
