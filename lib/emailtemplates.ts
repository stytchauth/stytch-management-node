// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import { ClientError } from "./shared/errors";
import { fetchConfig } from "./shared";
import { request } from "./shared";

export interface CustomHTMLCustomization {
  // TemplateType is the type of email template for which this custom HTML customization is valid.
  template_type?:
    | "LOGIN"
    | "SIGNUP"
    | "INVITE"
    | "RESET_PASSWORD"
    | "ONE_TIME_PASSCODE"
    | "ONE_TIME_PASSCODE_SIGNUP"
    | "VERIFY_EMAIL_PASSWORD_RESET"
    | "UNLOCK"
    | "PREBUILT"
    | string;
  // HTMLContent is the HTML content of the email body.
  html_content?: string;
  // PlaintextContent is the plaintext content of the email body.
  plaintext_content?: string;
  // Subject is the subject line in the email template.
  subject?: string;
}

export interface EmailTemplate {
  /**
   * TemplateID is a unique identifier to use for the template – this is how you will refer to the template
   * when sending emails from your project or managing this template. It can never be changed after creation.
   */
  template_id: string;
  // Name is a human-readable name. This does not have to be unique.
  name?: string;
  /**
   * SenderInformation is information about the email sender, such as the reply address or rendered name.
   * This is an optional field for PrebuiltCustomization, but required for CustomHTMLCustomization.
   */
  sender_information?: SenderInformation;
  /**
   * PrebuiltCustomization is customization related to prebuilt fields (such as button color) for prebuilt
   * email templates.
   */
  prebuilt_customization?: PrebuiltCustomization;
  // CustomHTMLCustomization is customization defined for completely custom HTML email templates.
  custom_html_customization?: CustomHTMLCustomization;
}

export interface PrebuiltCustomization {
  // ButtonBorderRadius is the radius of the button border in the email body.
  button_border_radius?: number;
  // ButtonColor is the color of the button in the email body.
  button_color?: string;
  // ButtonTextColor is the color of the text in the button in the email body.
  button_text_color?: string;
  // FontFamily is the font type to be used in the email body.
  font_family?:
    | "ARIAL"
    | "BRUSH_SCRIPT_MT"
    | "COURIER_NEW"
    | "GEORGIA"
    | "HELVETICA"
    | "TAHOMA"
    | "TIMES_NEW_ROMAN"
    | "TREBUCHET_MS"
    | "VERDANA"
    | string;
  // TextAlignment is the alignment of the text in the email body.
  text_alignment?: "LEFT" | "CENTER" | string;
}

export interface SenderInformation {
  /**
   * FromLocalPart is the prefix of the sender’s email address, everything before the @ symbol (e.g.,
   * first.last).
   */
  from_local_part?: string;
  /**
   * FromDomain is the postfix of the sender’s email address, everything after the @ symbol (e.g.,
   * stytch.com).
   */
  from_domain?: string;
  // FromName is the sender of the email (e.g., Login).
  from_name?: string;
  /**
   * ReplyToLocalPart is the prefix of the reply-to email address, everything before the @ symbol (e.g.,
   * first.last).
   */
  reply_to_local_part?: string;
  // ReplyToName is the sender of the reply-to email address (e.g., Support).
  reply_to_name?: string;
}

// Request type for `emailTemplates.create`.
export interface CreateRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  /**
   * TemplateID is a unique identifier to use for the template – this is how you will refer to the template
   * when sending emails from your project or managing this template. It can never be changed after creation.
   */
  template_id: string;
  // Name is a human-readable name. This does not have to be unique.
  name?: string;
  /**
   * SenderInformation is information about the email sender, such as the reply address or rendered name.
   * This is an optional field for PrebuiltCustomization, but required for CustomHTMLCustomization.
   */
  sender_information?: SenderInformation;
  /**
   * PrebuiltCustomization is customization related to prebuilt fields (such as button color) for prebuilt
   * email templates.
   */
  prebuilt_customization?: PrebuiltCustomization;
  // CustomHTMLCustomization is customization defined for completely custom HTML email templates.
  custom_html_customization?: CustomHTMLCustomization;
}

// Response type for `emailTemplates.create`.
export interface CreateResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // EmailTemplate is the email template that was created.
  email_template: EmailTemplate;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `emailTemplates.delete`.
export interface DeleteRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  /**
   * TemplateID is a unique identifier to use for the template – this is how you will refer to the template
   * when sending emails from your project or managing this template. It can never be changed after creation.
   */
  template_id: string;
}

// Response type for `emailTemplates.delete`.
export interface DeleteResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `emailTemplates.getAll`.
export interface GetAllRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
}

// Response type for `emailTemplates.getAll`.
export interface GetAllResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // EmailTemplates is a list of all active email templates for the project.
  email_templates: EmailTemplate[];
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `emailTemplates.getDefault`.
export interface GetDefaultRequest {
  // ProjectSlug is the slug of the project to retrieve.
  project_slug: string;
  // EmailTemplateType is the template type for which to get the default email template.
  email_template_type?:
    | "LOGIN"
    | "SIGNUP"
    | "INVITE"
    | "RESET_PASSWORD"
    | "ONE_TIME_PASSCODE"
    | "ONE_TIME_PASSCODE_SIGNUP"
    | "VERIFY_EMAIL_PASSWORD_RESET"
    | "UNLOCK"
    | "PREBUILT"
    | string;
}

// Response type for `emailTemplates.getDefault`.
export interface GetDefaultResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  /**
   * TemplateID is a unique identifier to use for the template – this is how you will refer to the template
   * when sending emails from your project or managing this template. It can never be changed after creation.
   */
  template_id: string;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `emailTemplates.get`.
export interface GetRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  /**
   * TemplateID is a unique identifier to use for the template – this is how you will refer to the template
   * when sending emails from your project or managing this template. It can never be changed after creation.
   */
  template_id: string;
}

// Response type for `emailTemplates.get`.
export interface GetResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // EmailTemplate is the email template.
  email_template: EmailTemplate;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `emailTemplates.setDefault`.
export interface SetDefaultRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  /**
   * TemplateID is a unique identifier to use for the template – this is how you will refer to the template
   * when sending emails from your project or managing this template. It can never be changed after creation.
   */
  template_id: string;
  // EmailTemplateType is the template type.
  email_template_type?:
    | "LOGIN"
    | "SIGNUP"
    | "INVITE"
    | "RESET_PASSWORD"
    | "ONE_TIME_PASSCODE"
    | "ONE_TIME_PASSCODE_SIGNUP"
    | "VERIFY_EMAIL_PASSWORD_RESET"
    | "UNLOCK"
    | "PREBUILT"
    | string;
}

// Response type for `emailTemplates.setDefault`.
export interface SetDefaultResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `emailTemplates.unsetDefault`.
export interface UnsetDefaultRequest {
  // ProjectSlug is the slug of the project for which to unset the default email template.
  project_slug: string;
  /**
   * EmailTemplateType is the template type for which to unset the default email template. Note that
   * unsetting the PREBUILT type is not supported.
   */
  email_template_type?:
    | "LOGIN"
    | "SIGNUP"
    | "INVITE"
    | "RESET_PASSWORD"
    | "ONE_TIME_PASSCODE"
    | "ONE_TIME_PASSCODE_SIGNUP"
    | "VERIFY_EMAIL_PASSWORD_RESET"
    | "UNLOCK"
    | "PREBUILT"
    | string;
}

// Response type for `emailTemplates.unsetDefault`.
export interface UnsetDefaultResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

// Request type for `emailTemplates.update`.
export interface UpdateRequest {
  // ProjectSlug is the slug of the project.
  project_slug: string;
  /**
   * TemplateID is a unique identifier to use for the template – this is how you will refer to the template
   * when sending emails from your project or managing this template. It can never be changed after creation.
   */
  template_id: string;
  // Name is a human-readable name. This does not have to be unique.
  name?: string;
  /**
   * SenderInformation is information about the email sender, such as the reply address or rendered name.
   * This is an optional field for PrebuiltCustomization, but required for CustomHTMLCustomization.
   */
  sender_information?: SenderInformation;
  /**
   * PrebuiltCustomization is customization related to prebuilt fields (such as button color) for prebuilt
   * email templates.
   */
  prebuilt_customization?: PrebuiltCustomization;
  // CustomHTMLCustomization is customization defined for completely custom HTML email templates.
  custom_html_customization?: CustomHTMLCustomization;
}

// Response type for `emailTemplates.update`.
export interface UpdateResponse {
  // RequestID is a unique identifier to help with debugging the request.
  request_id: string;
  // EmailTemplate is the newly updated email template.
  email_template: EmailTemplate;
  // StatusCode is the HTTP status code for the response.
  status_code: number;
}

export class EmailTemplates {
  private fetchConfig: fetchConfig;

  constructor(fetchConfig: fetchConfig) {
    this.fetchConfig = fetchConfig;
  }

  /**
   * Create creates an email template for a project.
   * @param data {@link CreateRequest}
   * @returns {@link CreateResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async create(data: CreateRequest): Promise<CreateResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    return request<CreateResponse>(this.fetchConfig, {
      method: "POST",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/email_templates`,
      data: {
        template_id: data.template_id,
        name: data.name,
        sender_information: data.sender_information,
        prebuilt_customization: data.prebuilt_customization,
        custom_html_customization: data.custom_html_customization,
      },
    });
  }

  /**
   * Get retrieves an email template for a project.
   * @param params {@link GetRequest}
   * @returns {@link GetResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async get(params: GetRequest): Promise<GetResponse> {
    if (!params.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!params.template_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "template_id cannot be empty"
      );
    }
    return request<GetResponse>(this.fetchConfig, {
      method: "GET",
      url: `/pwa/v3/projects/${encodeURIComponent(
        params.project_slug
      )}/email_templates/${encodeURIComponent(params.template_id)}`,
      params: {},
    });
  }

  /**
   * GetAll retrieves all email templates for a project.
   * @param params {@link GetAllRequest}
   * @returns {@link GetAllResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async getAll(params: GetAllRequest): Promise<GetAllResponse> {
    if (!params.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    return request<GetAllResponse>(this.fetchConfig, {
      method: "GET",
      url: `/pwa/v3/projects/${encodeURIComponent(
        params.project_slug
      )}/email_templates`,
      params: {},
    });
  }

  /**
   * Update updates an email template for a project.
   * @param data {@link UpdateRequest}
   * @returns {@link UpdateResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async update(data: UpdateRequest): Promise<UpdateResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.template_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "template_id cannot be empty"
      );
    }
    return request<UpdateResponse>(this.fetchConfig, {
      method: "PUT",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/email_templates/${encodeURIComponent(data.template_id)}`,
      data: {
        name: data.name,
        sender_information: data.sender_information,
        prebuilt_customization: data.prebuilt_customization,
        custom_html_customization: data.custom_html_customization,
      },
    });
  }

  /**
   * Delete deletes an email template for a project.
   * @param data {@link DeleteRequest}
   * @returns {@link DeleteResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async delete(data: DeleteRequest): Promise<DeleteResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.template_id) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "template_id cannot be empty"
      );
    }
    return request<DeleteResponse>(this.fetchConfig, {
      method: "DELETE",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/email_templates/${encodeURIComponent(data.template_id)}`,
      data: {},
    });
  }

  /**
   * SetDefault sets the default email template for a specific template type in a project.
   * @param data {@link SetDefaultRequest}
   * @returns {@link SetDefaultResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async setDefault(data: SetDefaultRequest): Promise<SetDefaultResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.email_template_type) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "email_template_type cannot be empty"
      );
    }
    return request<SetDefaultResponse>(this.fetchConfig, {
      method: "POST",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/default_email_templates/${encodeURIComponent(
        data.email_template_type
      )}`,
      data: {
        template_id: data.template_id,
      },
    });
  }

  /**
   * GetDefault retrieves the default email template for a specific template type in a project.
   * @param params {@link GetDefaultRequest}
   * @returns {@link GetDefaultResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async getDefault(params: GetDefaultRequest): Promise<GetDefaultResponse> {
    if (!params.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!params.email_template_type) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "email_template_type cannot be empty"
      );
    }
    return request<GetDefaultResponse>(this.fetchConfig, {
      method: "GET",
      url: `/pwa/v3/projects/${encodeURIComponent(
        params.project_slug
      )}/default_email_templates/${encodeURIComponent(
        params.email_template_type
      )}`,
      params: {},
    });
  }

  /**
   * UnsetDefault removes the default email template for a specific template type in a project.
   * @param data {@link UnsetDefaultRequest}
   * @returns {@link UnsetDefaultResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  async unsetDefault(data: UnsetDefaultRequest): Promise<UnsetDefaultResponse> {
    if (!data.project_slug) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "project_slug cannot be empty"
      );
    }
    if (!data.email_template_type) {
      throw new ClientError(
        "MISSING_PATH_PARAMETER",
        "email_template_type cannot be empty"
      );
    }
    return request<UnsetDefaultResponse>(this.fetchConfig, {
      method: "DELETE",
      url: `/pwa/v3/projects/${encodeURIComponent(
        data.project_slug
      )}/default_email_templates/${encodeURIComponent(
        data.email_template_type
      )}`,
      data: {},
    });
  }
}
